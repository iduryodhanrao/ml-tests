# -*- coding: utf-8 -*-
"""yolo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16SnnPLjtywFfmEAP3xBFEgx4vhRRtO1D

# Fine Tuning YOLO for a Custom Dataset
This notebook creates a custom dataset with annotation files expected by YOLO, performs the fine tuning and displays the results of the best model.

## Create the Dataset
The following code dynamically creates a YOLO dataset of randomly sized and colored circles and triangles on a noisy background.
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import numpy as np
import os
import math
import shutil
from IPython.display import Image, display, Code
from matplotlib import pyplot as plt
from ultralytics import YOLO
# %matplotlib inline

# Specify a root location for the dataset
DATA_DIR = "./datasets"

# Specify the hight and width of the images in the dataset (640 is the default YOLO size)
IMG_WIDTH = 640
IMG_HEIGHT = 640

# Remove old datasets and previous training data
paths = ['runs/detect', f'{DATA_DIR}/test', f'{DATA_DIR}/train', f'{DATA_DIR}/val']
for path in paths:
    if os.path.exists(path):
        shutil.rmtree(path)

"""Notice how the width and height are used to make the annotations resilient to image resizing in the method below."""

# Convert from bounding boxes and image size to YOLO representations
def get_yolo_annotations(x1, y1, x2, y2, w, h):
    center_x = (x2+x1)/2/w
    center_y = (y2+y1)/2/h
    width    = (x2-x1)/w
    height   = (y2-y1)/h
    return center_x, center_y, width, height

# Write annotations in YOLO format
def write_yolo_annotations(x1, y1, x2, y2, w, h, label_file, class_id):

    # Get YOLO annotations
    center_x, center_y, width, height = get_yolo_annotations(x1, y1, x2, y2, w, h)

    # Make sure values are reasonable
    if center_x > 0 and center_y > 0 and width > 0 and height > 0 and \
       center_x < 1 and center_y < 1 and width < 1 and height < 1:

        # Write the annotiations
        f = open(label_file, 'a')
        f.write('{} {} {} {} {}\n'.format(class_id, center_x, center_y, width, height))
        f.close()
    else:
        print(f"At least a portion of the class is outside the image boundary ({center_x}, {center_y}, {width}, {height})")

def draw_random_circle(img):
    radius = np.random.randint(10, 100)
    center_x = np.random.randint(radius, IMG_WIDTH-radius)
    center_y = np.random.randint(radius, IMG_HEIGHT-radius)
    color = (np.random.randint(0, 255), np.random.randint(0, 255), np.random.randint(0, 255))
    cv2.circle(img, (center_x, center_y), radius, color, -1)

    return center_x, center_y, radius

def draw_random_triangle(img):
    pt1 = (np.random.randint(100, IMG_WIDTH-100), np.random.randint(100, IMG_HEIGHT-100))
    pt2 = (pt1[0]+np.random.randint(50, 100), pt1[1]+np.random.randint(50, 100))
    pt3 = (pt1[0]-np.random.randint(50, 100), pt1[1]+np.random.randint(50, 100))
    triangle_cnt = np.array( [pt1, pt2, pt3] )

    color = (np.random.randint(0, 255), np.random.randint(0, 255), np.random.randint(0, 255))
    cv2.drawContours(img, [triangle_cnt], 0, color, -1)

    x_vals = [x[0] for x in triangle_cnt]
    y_vals = [x[1] for x in triangle_cnt]
    return np.min(x_vals), np.max(x_vals), np.min(y_vals), np.max(y_vals)

CIRCLE_CLASS_ID = 0
TRIANGLE_CLASS_ID = 1

def create_data(dir, num_images):
    img_dir   = os.path.join(DATA_DIR, dir, "images")
    label_dir = os.path.join(DATA_DIR, dir, "labels")
    os.makedirs(img_dir,   exist_ok=True)
    os.makedirs(label_dir, exist_ok=True)

    for i in range(num_images):
        img = np.random.randint(0, 255, (IMG_HEIGHT, IMG_WIDTH, 3), "uint8")
        img_file   = "{}/{}.jpg".format(img_dir,   i)
        label_file = "{}/{}.txt".format(label_dir, i)

        center_x, center_y, radius = draw_random_circle(img)
        write_yolo_annotations(center_x-radius, center_y-radius, center_x+radius, center_y+radius, IMG_WIDTH, IMG_HEIGHT, label_file, CIRCLE_CLASS_ID)

        x_min, x_max, y_min, y_max = draw_random_triangle(img)
        write_yolo_annotations(x_min, y_min, x_max, y_max, IMG_WIDTH, IMG_HEIGHT, label_file, TRIANGLE_CLASS_ID)

        cv2.imwrite(img_file, img)

create_data("train", 150)
create_data("test", 25)
create_data("val", 10)

"""Let's print out one of our validation images and annotations to make sure everything looks right"""

val_images_dir = 'datasets/val/images/'
images = ["{}{}".format(val_images_dir, image) for image in os.listdir(val_images_dir)]
images.sort()
display(Image(filename=images[0]))
#print(images)

val_anno_dir = 'datasets/val/labels/'
labels = ["{}{}".format(val_anno_dir, label) for label in os.listdir(val_anno_dir)]
labels.sort()
Code(filename=labels[0], language='python')
#print(labels)

"""# Train the Model
Create the configuration file if it doesn't exist.
"""

config_file = 'object_v8.yaml'

if not os.path.exists(config_file):
    f = open(config_file, "x")
    f.write('''
# Train and test folders
train: 'train'
val: 'test'

# Number of classes
nc: 2
names: ['circle', 'triangle']
''')
    f.close()

"""Start training."""

YOLO_MODEL = 'yolov8n'

model = YOLO('{}.pt'.format(YOLO_MODEL))

results = model.train(
    data = config_file,
    imgsz = 640,
    epochs = 50,
    batch = 64,
    #device='cpu',
    name = YOLO_MODEL
)

"""Let's look at a graphical version of the output"""

display(Image(filename=f'runs/detect/{YOLO_MODEL}/results.png'))

"""# Run YOLO
Now that we've trained on our classes let's see how it performs on the validation data.
"""

def show_image(path, boxes=[], classes=[]):
    img = cv2.imread(path, cv2.IMREAD_COLOR)

    for box, class_id in zip(boxes, classes):
        if class_id == CIRCLE_CLASS_ID:
            box_color = (0, 0, 255)
        elif class_id == TRIANGLE_CLASS_ID:
            box_color = (0, 255, 0)
        else:
            box_color = (255, 0, 0)

        x1 = int(box[0])
        y1 = int(box[1])
        x2 = int(box[2])
        y2 = int(box[3])
        img = cv2.rectangle(img, (x1,y1), (x2,y2), box_color, 3)

    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.imshow(img)
    plt.show()

best_yolo_model = f'runs/detect/{YOLO_MODEL}/weights/best.pt'
val_images_dir = f'{DATA_DIR}/val/images/'

model = YOLO(best_yolo_model)
test_images = ["{}{}".format(val_images_dir, image) for image in os.listdir(val_images_dir)]
batch_size = 64

for i in range(0, len(test_images), batch_size):
    results = model.predict(test_images[i:i + batch_size])
    for res in results:
        show_image(res.path, res.boxes.xyxy.detach().cpu().numpy(), res.boxes.cls.detach().cpu().numpy())

